# 倒排索引
??? info
	这部分内容主要是概念性的东西，比较抽象，本人描述的可能不是很好，可以根据参考资料进行学习（前两份是学长的笔记，第三份是同为24级混计的课友的笔记）。
**倒排索引（inverted file index）**是一种常见的文本检索技术，用于快速查找包含特定单词或短语的文档。它通过将单词或短语作为关键字，并将它们出现在文档中的位置记录在一个索引中，从而支持快速的文本检索。在搜索过程中，系统可以快速地定位包含指定单词或短语的文档，并返回它们的相关信息。倒排索引广泛应用于搜索引擎、数据库系统和信息检索等领域。
## 结构
假如有以下文本：

| Doc | Text |
| :----------: | :----------: |
| 1 | Gold silver truck |
| 2 | Shipment of gold damaged in a fire |
| 3 | Delivery of silver arrived in a silver truck |
| 4 | Shipment of gold arrived in a truck |

那么我们可以得到如下的倒排索引：

| No. | Term | Times; (DocId; Places) |
| :----------: | :----------: | :----------: |
| 1 | a | {3;(2;6),(3;6),(4;6)} |
| 2 | arrived | {2;(3;4),(4;4)} |
| 3 | damaged | {1;(2;4)} |
| 4 | delivery | {1;(3;1)} |
| 5 | fire | {1;(2;7)} |
| 6 | gold | {3;(1;1),(2;3),(4;3)} |
| 7 | of | {3;(2;2),(3;2),(4;2)} |
| 8 | in | {3;(2;5),(3;5),(4;5)} |
| 9 | shipment | {2;(2;1),(4;1)} |
| 10 | silver | {2;(1;2),(3;3,7)} |
| 11 | truck | {3;(1;3),(3;8),(4;7)} |

实际上就是把文档全部遍历一遍，存一下每个词在哪里出现过即可。

记录每个词出现了几次是为了加快搜索速度。若输入多个关键词，则优先搜索出现次数少的。

??? 伪代码
	```
	while (read a document D) {
		while (read a term T in D) {
			if (Find(Dictionary, T) == false)
				Insert(Dictionary, T);
			Get T posting list;
			Insert a node to T posting list;
		}
	}
	Write the inverted index to disk;
	```
## 模块
### 词性还原
同一个单词可能有不同种类的形式，如 alarm 这个词有以下变种：

- alarm(n./vt.)
- alarms(pl./三单)
- alarming(adj./v-ing)
- alarmed(过去式/过去分词)

可将这些词都变为同一种形式以提高**召回率**。

也可以把常见的拼写错误也归入同一个词干。!mask[当然也有像conversation和conservation这样的易混词]
### 停用词
某些过于常见、几乎出现在任何文档中的词称为**停用词**，如 a, the
停用词一般不具备特殊含义，可以预先从原始文本中删除，在进行倒排索引的匹配。

??? warning
	不能简单地将出现频率高的词视为停用词。
### 词项访问
- B树/B+树（优点：查找、插入、删除较稳定，适合磁盘存储；缺点：实现复杂，占空间较多）
- 字典树（优点：对字符串查找极快，支持前缀搜索；缺点：空间开销大）
- 哈希表（优点：单个词查找速度最快；缺点：多个词汇的位置不确定、可能相距很远，不支持范围查找）
### 内存管理
在内存中累积一个块的词典和倒排表。一旦内存达到上限，就把该块序列化并写在磁盘，清空内存结构，继续处理下一个块。最后将所有块外部合并成最终的倒排索引。
??? 伪代码
	```
	BlockCnt = 0;
	while (read a document D) {
		while (read a term T in D) {
			if (out of memory) {
				Write BlockIndex[BlockCnt] to disk;
				BlockCnt++;
				FreeMemory;
			}

			if (Find(Dictionary, T) == false)
				Insert(Dictionary, T);
			Get T's posting list;
			Insert a node to T's posting list;
		}
	}
	for (i = 0; i < BlockCnt; i++)
		Merge(InvertedIndex, BlockIndex[i]);
	```
## 实现
### 索引分配
实际中数据量很大，不可能放在同一台计算机内。将倒排索引放在多台计算机内，这些计算机称为**集群（cluster）**。其中每一天计算机称为**节点（node）**，每个节点存储整体倒排索引的一个子集。

其划分方法可分为：按词汇编号划分；按文档编号划分

??? info
	这两种划分方法无优劣之分。
### 动态索引
文档随时有可能被插入或删除，如果每次都重新处理一遍，效率会很低。

将原先的索引称为**主索引**；另外新增一个存储少量索引的空间，称为**辅助索引**，用于存放新增文档的索引。

用关键词搜索时，搜索引擎会同时在主索引和辅助索引中搜索；在适当的时候将辅助索引的内容合并到主索引（归档），同时清空辅助索引。
### 空间压缩
如果将所有词汇存储在数组中，存储空间取决于最长单词的长度，浪费空间多。（空间开销为 $n\times l$，其中 $n$ 为词汇数量，$l$ 为最长词汇长度，显然远大于平均长度）

一种压缩方法：

- 去除停用词
- 将所有的词汇放在同一个存储块内，词汇之间没有任何间隔（类似字符串）
- 为了从字符串中分离出词汇，需要另一张小的表记录每个词汇开头的位置，同时为了避免索引值过大，记录的是相邻词汇开头的差分
- 这样将很大的数组压缩为两张较小的表。
### 阈值
设置**阈值（threshold）**的原因是：

- 让搜索引擎查找或检索所有相关的网页是没有必要的，因为我们人类的时间精力有限，即使搜出来的网页都有价值（而实际上只有很少的一部分网页是有意义的），我们也不会将所有给出的网页都阅读一遍
- 而且检索所有网页这一行为所消耗的时间较多，所以需要设定一个阈值，我们只要这个范围内的网页就行了。
#### 文档截断阈值
根据一定的权重进行排名，只取出靠前的 $x$ 个文档。

- 优点：减少不必要的文档计算或展示，提高响应速度。
- 缺点：可能会遗漏部分相关文档（召回率下降）。
- 示例：搜索引擎只展示前 1000 条结果。
#### 查询词阈值
对查询中的词项按出现频率升序排列，只用出现频率较低（更具区分性）的词项检索。

- 优点：显著减少访问倒排表的数量，提高效率。
- 缺点：若阈值过低，可能丢失相关结果（召回率下降）。
### 性能衡量
衡量搜索引擎性能，可以分为两大类：

- 系统性能：关注“速度”和“资源效率”，即搜索引擎运行得快不快、省不省资源。
- 检索性能：关注“结果质量”，即搜索引擎搜出来的结果是否有用、是否相关。
#### 系统性能
一般有以下标准：

- 索引速度：每小时处理的文档数量。
- 搜索速度：用户输入查询后，系统返回结果的速度。例如时延（Latency）这一指标，其表示从用户输入查询到看到结果的等待时间。
- 查询语句的可表达性：系统能否支持复杂查询（多关键词，带权重，模糊匹配等）的能力。
- 用户满意度：综合性指标，最终用户主观上的使用体验，主要有数据检索性能评估（data retrieval performance evaluation）与信息检索性能评估（information retrieval performance evaluation）这两个指标。
#### 检索性能
|  | Relavant | Irrelavent |
| :----------: | :----------: | :----------: |
| Retrived | $R_R$ | $I_R$ |
| Not Retrived | $R_N$ | $I_N$ |

精确度 $P$：所有检索到的文档中，有多少是有意义的（考虑表格第一行）

$$P=\frac{R_R}{R_R+I_R}$$

召回率 $R$：所有有意义的文档中，有多少是被检索到的（考虑表格第一列）

$$R=\frac{R_R}{R_R+R_N}$$

如果精确度高而召回率低，那么我们会错过很多有价值的网页；如果召回率高而精确度低，那么我们会得到很多无意义的网页；因此理想情况是同时具备较高的精确度和召回率，但实际应用中可能无法同时兼顾两者，需要做好权衡。

## 参考资料

- [NoughtQ 的笔记本-倒排索引](https://note.noughtq.top/algorithms/ads/3)
- [Isshiki 修's Notebook-倒排索引](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/Lec03/)
- [Abies's Notebook-倒排索引](https://abiesjqq.github.io/Abies_Notebook/CourseNotes/Advance%20Data%20Structure/ADS03/)